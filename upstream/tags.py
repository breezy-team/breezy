#    tags.py -- Providers of upstream source - tag names
#    Copyright (C) 2016-2020 Jelmer Vernooij <jelmer@debian.org>
#
#    This file is part of bzr-builddeb.
#
#    bzr-builddeb is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    bzr-builddeb is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with bzr-builddeb; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from itertools import islice
import re

from ....errors import (
    BzrError,
    NotBranchError,
    )
from ....trace import note


class GbpTagFormatError(BzrError):
    _fmt = 'Unknown variable %(variable)s in tag %(tag_name)s.'

    def __init__(self, tag_name, variable):
        self.variable = variable
        self.tag_name = tag_name


def gbp_expand_tag_name(tag_format, version):
    # See gbp/pkg/pkgpolicy.py in gbp-buildpackage
    version_mangle_re = (
        r'%\(version'
        r'%(?P<M>[^%])'
        r'%(?P<R>([^%]|\\%))+'
        r'\)s')

    ret = tag_format
    m = re.search(version_mangle_re, tag_format)
    if m:
        ret = re.sub(version_mangle_re, "%(version)s", tag_format)
        version = version.replace(
            m.group('M'), m.group('R').replace(r'\%', '%'))

    vars = {
        'version': version,
        'hversion': version.replace('.', '-'),
        }
    try:
        return ret % vars
    except KeyError as e:
        raise GbpTagFormatError(tag_format, e.args[0])


def upstream_tag_name(version, component=None, distro=None, git_style=False):
    if git_style:
        # In git, the convention is to use a slash
        if distro is None:
            name = "upstream/" + mangle_version_for_git(version)
        else:
            name = "upstream-%s/%s" % (distro, version.replace('~', '_'))
    else:
        if distro is None:
            name = "upstream-" + version
        else:
            name = "upstream-%s-%s" % (distro, version)
    if component is not None:
        name += "/%s" % component
    return name


def mangle_version_for_git(version):
    # See https://dep-team.pages.debian.net/deps/dep14/
    manipulated = (
        version.replace("~", "_").replace(':', '%').replace('..', '.#.'))
    if manipulated.endswith('.'):
        manipulated += '#'
    if manipulated.endswith('.lock'):
        manipulated = manipulated[:-4] + '#lock'
    return manipulated


def possible_upstream_tag_names(version, component=None):
    tags = []
    if component is None:
        # compatibility with git-buildpackage
        tags.append("upstream/%s" % version)
        tags.append("upstream-%s" % version)
        manipulated = 'upstream/%s' % mangle_version_for_git(version)
        if manipulated not in tags:
            tags.append(manipulated)
        # compatibility with svn-buildpackage
        tags.append("upstream_%s" % version)
        tags.append("%s" % version)
        tags.append("v%s" % version)
    else:
        tags.append(upstream_tag_name(version, component))
    return tags


def is_upstream_tag(tag):
    """Return true if tag is an upstream tag.

    :param tag: The string name of the tag.
    :return: True if the tag name is one generated by upstream tag operations.
    """
    return (tag.startswith('upstream-') or tag.startswith('upstream/') or
            tag.startswith('upstream_'))


def upstream_tag_version(tag):
    """Return the upstream version portion of an upstream tag name.

    :param tag: The string name of the tag.
    :return: tuple with version portion of the tag and component name
    """
    assert is_upstream_tag(tag), "Not an upstream tag: %s" % tag
    if tag.startswith('upstream/'):
        tag = tag[len('upstream/'):]
    elif tag.startswith('upstream_'):
        tag = tag[len('upstream_'):]
    elif tag.startswith('upstream-'):
        tag = tag[len('upstream-'):]
        if tag.startswith('debian-'):
            tag = tag[len('debian-'):]
        elif tag.startswith('ubuntu-'):
            tag = tag[len('ubuntu-'):]
    tag = tag.replace('_', '~')
    if '/' not in tag:
        return (None, tag)
    (version, component) = tag.rsplit('/', 1)
    if component == "":
        component = None
    return (component, version)


def _rev_is_upstream_import(revision, package, version):
    possible_messages = [
        'Import %s_%s' % (package, version),
        'import %s_%s' % (package, version),
        'import %s-%s' % (package.replace('-', '_'), version),
        'Imported upstream version %s' % version,
        'Import upstream version %s' % version,
        'New upstream version %s' % version,
        'New upstream version v%s' % version
        ]
    for possible_message in possible_messages:
        if revision.message.startswith(possible_message):
            return True
    return False


def _rev_is_upstream_merge(revision, package, version):
    if revision.message.startswith("Merge tag 'v%s' into debian/" % version):
        return True
    return False


def search_for_upstream_version(
        branch, package, version, component=None, md5=None, scan_depth=None):
    """Find possible upstream revisions that don't have appropriate tags."""
    start_revids = []
    sources = []
    try:
        upstream_branch = branch.controldir.open_branch('upstream')
    except NotBranchError:
        sources.append('main branch')
        start_revids.append(branch.last_revision())
    else:
        sources.append('branch upstream')
        start_revids.append(upstream_branch.last_revision())
    git_tag_start = 'debian/%s-' % mangle_version_for_git(version)
    bzr_tag_start = 'debian-%s' % version
    for tag_name, revid in branch.tags.get_tag_dict().items():
        if (tag_name.startswith(git_tag_start) or
                tag_name.startswith(bzr_tag_start)):
            sources.append('tag %s' % tag_name)
            start_revids.append(revid)
    note('Searching for revision importing %s version %s on %s.',
         package, version, ', '.join(sources))
    todo = []
    graph = branch.repository.get_graph()
    for revid, parents in islice(
            graph.iter_ancestry(start_revids), scan_depth):
        todo.append(revid)
    for revid, rev in branch.repository.iter_revisions(todo):
        if rev is None:
            continue
        if _rev_is_upstream_import(rev, package, version):
            return revid

    # Try again, but this time search for merge revisions
    for revid, rev in branch.repository.iter_revisions(todo):
        if rev is None:
            continue
        if _rev_is_upstream_merge(rev, package, version):
            return rev.parent_ids[1]
    return None
