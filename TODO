.. -*- mode: indented-text; compile-command: "make -C doc" -*- 


*******************
Things to do in bzr
*******************


See also various low-level TODOs in the source code.  Try looking in
the list archive or on gmane.org for previous discussion of these
issues.

These are classified by approximate size: an hour or less, a day or
less, and several days or more.


Small things
------------

* Merging add of a new file clashing with an existing file doesn't
  work; add gets an error that it's already versioned and the merge
  aborts.

* Merge should ignore the destination's working directory, otherwise
  we get an error about the statcache when pulling from a remote
  branch.

* Add of a file that was present in the base revision should put back
  the previous file-id.

* Handle diff of files which do not have a trailing newline; probably
  requires patching difflib to get it exactly right, or otherwise
  calling out to GNU diff.

* -r option should take a revision-id as well as a revno.

* ``bzr info`` should count only people with distinct email addresses as
  different committers.  (Or perhaps only distinct userids?)

* On Windows, command-line arguments should be `glob-expanded`__,
  because the shell doesn't do this.  However, there are probably some
  commands where this shouldn't be done, such as 'bzr ignore', because
  we want to accept globs.

* ``bzr ignore`` command that just adds a line to the ``.bzrignore`` file
  and makes it versioned.  Fix this to break symlinks.

* Any useful sanity checks in 'bzr ignore'?  Perhaps give a warning if
  they try to add a single file which is already versioned, or if they
  add a pattern which already exists, or if it looks like they gave an
  unquoted glob.

__ http://mail.python.org/pipermail/python-list/2001-April/037847.html

* Separate read and write version checks?

* ``bzr status DIR`` should give status on all files under that
  directory.

* ``bzr log DIR`` should give changes to any files within DIR.

* ``bzr inventory -r REV`` and perhaps unify this with ``bzr ls``,
  giving options to display ids, types, etc.

* Split BzrError into various more specific subclasses for different
  errors people might want to catch.

* If the export destination ends in '.tar', '.tar.gz', etc then create
  a tarball instead of a directory.  (Need to actually make a
  temporary directory and then tar that up.)

  http://www.gelato.unsw.edu.au/archives/git/0504/2194.html
  
* RemoteBranch could maintain a cache either in memory or on disk.  We
  know more than an external cache might about which files are
  immutable and which can vary.  On the other hand, it's much simpler
  to just use an external proxy cache.

  Perhaps ~/.bzr/http-cache.  Baz has a fairly simple cache under
  ~/.arch-cache, containing revision information encoded almost as a
  bunch of archives.  Perhaps we could simply store full paths.

* Maybe also store directories in the statcache so that we can quickly
  identify that they still exist.

* Diff should show timestamps; for files from the working directory we
  can use the file itself; for files from a revision we should use the
  commit time of the revision.

* Perhaps split command infrastructure from the actual command
  definitions.

* Cleaner support for negative boolean options like --no-recurse.

* Statcache should possibly map all file paths to / separators

* quotefn doubles all backslashes on Windows; this is probably not the
  best thing to do.  What would be a better way to safely represent
  filenames?  Perhaps we could doublequote things containing spaces,
  on the principle that filenames containing quotes are unlikely?
  Nice for humans; less good for machine parsing.

* Patches should probably use only forward slashes, even on Windows,
  otherwise Unix patch can't apply them. (?) 

* Branch.update_revisions() inefficiently fetches revisions from the
  remote server twice; once to find out what text and inventory they
  need and then again to actually get the thing.  This is a bit
  inefficient. 

  One complicating factor here is that we don't really want to have
  revisions present in the revision-store until all their constituent
  parts are also stored.

  The basic problem is that RemoteBranch.get_revision() and similar
  methods return object, but what we really want is the raw XML, which
  can be popped into our own store.  That needs to be refactored.

* ``bzr status FOO`` where foo is ignored should say so.

* ``bzr mkdir A...`` should just create and add A.

* Guard against repeatedly merging any particular patch.
  


Medium things
-------------

* Merge revert patch.

* ``bzr mv`` that does either rename or move as in Unix.

* More efficient diff of only selected files.  We should be able to
  just get the id for the selected files, look up their location and
  diff just those files.  No need to traverse the entire inventories.

* ``bzr status DIR`` or ``bzr diff DIR`` should report on all changes
  under that directory.

* Fix up Inventory objects to represent root object as an entry.

* Don't convert entire entry from ElementTree to an object when it is
  read in, but rather wait until the program actually wants to know
  about that node.

* Extract changes from one revision to the next to a text form
  suitable for transmission over email.

* More test cases.

  - Selected-file commit

  - Impossible selected-file commit: adding things in non-versioned
    directories, crossing renames, etc.

* Write a reproducible benchmark, perhaps importing various kernel versions.

* Directly import diffs!  It seems a bit redundant to need to rescan
  the directory to work out what files diff added/deleted/changed when
  all the information is there in the diff in the first place.
  Getting the exact behaviour for added/deleted subdirectories etc
  might be hard.

  At the very least we could run diffstat over the diff, or perhaps
  read the status output from patch.  Just knowing which files might
  be modified would be enough to guide the add and commit.
  
  Given this we might be able to import patches at 1/second or better.

* Get branch over http.

* Pull pure updates over http.

* revfile compression.

* Split inventory into per-directory files.

* Fix ignore file parsing:

  - fnmatch is not the same as unix patterns

  - perhaps add extended globs from rsh/rsync

  - perhaps a pattern that matches only directories or non-directories

* Consider using Python logging library as well as/instead of
  bzrlib.trace.

* Commands should give some progress indication by default.

  - But quieten this with ``--silent``.

* Change to using gettext message localization.

* Make a clearer separation between internal and external bzrlib
  interfaces.  Make internal interfaces use protected names.  Write at
  least some documentation for those APIs, probably as docstrings.

  Consider using ZopeInterface definitions for the external interface;
  I think these are already used in PyBaz.  They allow automatic
  checking of the interface but may be unfamiliar to general Python
  developers, so I'm not really keen.

* Commands to dump out all command help into a manpage or HTML file or
  whatever.

* Handle symlinks in the working directory; at the very least it
  should be possible for them to be present and ignored/unknown
  without causing assertion failures. 

  Eventually symlinks should be versioned.

* Allow init in a subdirectory to create a nested repository, but only
  if the subdirectory is not already versioned.   Perhaps also require
  a ``--nested`` to protect against confusion.

* Branch names? 

* More test framework:

  - Class that describes the state of a working tree so we can just
    assert it's equal.

* There are too many methods on Branch() that really manipulate the
  WorkingTree.  They should be moved across.  

  Also there are some methods which are duplicated on Tree and
  Inventory objects, and it should be made more clear which ones are
  proxies and which ones behave differently, and how.

* Try using XSLT to add some formatting to REST-generated HTML.  Or
  maybe write a small Python program that specifies a header and foot
  for the pages and calls into the docutils libraries.

* --format=xml for log, status and other commands.

* Attempting to explicitly add a file that's already added should give
  a warning; however there should be no warning for directories (since
  we scan for new children) or files encountered in a directory that's
  being scanned.

* Better handling of possible collisions on case-losing filesystems;
  make sure a single file does not get added twice under different
  names.

* Clean up XML inventory:

  - Use nesting rather than parent_id pointers.

  - Hold the ElementTree in memory in the Inventory object and work
    directly on that, rather than converting into Python objects every
    time it is read in.  Probably still exposoe it through some kind of
    object interface though, but perhaps that should just be a proxy
    for the elements.

  - Less special cases for the root directory. 

* Perhaps inventories should remember the revision in which each file
  was last changed, as well as its current state?  This is a bit
  redundant but might often be interested to know.

* stat cache should perhaps only stat files as necessary, rather than
  doing them all up-front.  On the other hand, that disallows the
  opimization of stating them in inode order.

* It'd be nice to pipeline multiple HTTP requests.  Often we can
  predict what will be wanted in future: all revisions, or all texts
  in a particular revision, etc.  

  urlgrabber's docs say they are working on batched downloads; we
  could perhaps ride on that or just create a background thread (ew).

* Paranoid mode where we never trust SHA-1 matches.

* Don't commit if there are no changes unless forced.

* --dry-run mode for commit?  (Or maybe just run with
  check-command=false?)

* Generally, be a bit more verbose unless --silent is specified.

* Function that finds all changes to files under a given directory;
  perhaps log should use this if a directory is given.

* XML attributes might have trouble with filenames containing \n and
  \r.  Do we really want to support this?  I think perhaps not.

* Remember execute bits, so that exports will work OK.

* Unify smart_add and plain Branch.add(); perhaps smart_add should
  just build a list of files to add and pass that to the regular add
  function.

* Function to list a directory, saying in which revision each file was
  last modified.  Useful for web and gui interfaces, and slow to
  compute one file at a time.

* unittest is standard, but the results are kind of ugly; would be
  nice to make it cleaner.

* Check locking is correct during merge-related operations.

* Perhaps attempts to get locks should timeout after some period of
  time, or at least display a progress message.

* Split out upgrade functionality from check command into a separate
  ``bzr upgrade``.

* Don't pass around command classes but rather pass objects.  This'd
  make it cleaner to construct objects wrapping external commands.

* Track all merged-in revisions in a versioned add-only metafile.


Large things
------------

* Generate annotations from current file relative to previous
  annotations.

  - Is it necessary to store any kind of annotation where data was
    deleted?

* Update revfile_ format and make it active:

  - Texts should be identified by something keyed on the revision, not
    an individual text-id.  This is much more useful for annotate I
    think; we want to map back to the revision that last changed it.

  - Access revfile revisions through the Tree/Store classes.

  - Check them from check commands.

  - Store annotations.

.. _revfile: revfile.html

* Hooks for pre-commit, post-commit, etc.

  Consider the security implications; probably should not enable hooks
  for remotely-fetched branches by default.

* Pre-commit check.  If this hook is defined, it needs to be handled
  specially: create a temporary directory containing the tree as it
  will be after the commit.  This means excluding any ignored/unknown
  files, and respecting selective commits.  Run the pre-commit check
  (e.g. compile and run test suite) in there.

  Possibly this should be done by splitting the commit function into
  several parts (under a single interface).  It is already rather
  large.  Decomposition:

   - find tree modifications and prepare in-memory inventory

   - export that inventory to a temporary directory

   - run the test in that temporary directory

   - if that succeeded, continue to actually finish the commit

  What should be done with the text of modified files while this is
  underway?  I don't think we want to count on holding them in memory
  and we can't trust the working files to stay in one place so I
  suppose we need to move them into the text store, or otherwise into
  a temporary directory.

  If the commit does not actually complete, we would rather the
  content was not left behind in the stores.  

* Web interface

* GUI (maybe in Python GTK+?)

* C library interface

* Expansion of $Id$ keywords within working files.  Perhaps do this in
  exports first as a simpler case because then we don't need to deal
  with removing the tags on the way back in.

* ``bzr find``
