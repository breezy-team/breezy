=======================
Guide to Testing Bazaar
=======================

.. contents::

Testing Bazaar
##############

The Importance of Testing
=========================

Reliability is a critical success factor for any Version Control System.
We want Bazaar to be highly reliable across multiple platforms while
evolving over time to meet the needs of its community.

In a nutshell, this is what we expect and encourage:

* New functionality should have test cases.  Preferably write the
  test before writing the code.

  In general, you can test at either the command-line level or the
  internal API level.  See `Writing tests`_ below for more detail.

* Try to practice Test-Driven Development: before fixing a bug, write a
  test case so that it does not regress.  Similarly for adding a new
  feature: write a test case for a small version of the new feature before
  starting on the code itself.  Check the test fails on the old code, then
  add the feature or fix and check it passes.

By doing these things, the Bazaar team gets increased confidence that
changes do what they claim to do, whether provided by the core team or
by community members. Equally importantly, we can be surer that changes
down the track do not break new features or bug fixes that you are
contributing today.

As of May 2008, Bazaar ships with a test suite containing over 12000 tests
and growing. We are proud of it and want to remain so. As community
members, we all benefit from it. Would you trust version control on
your project to a product *without* a test suite like Bazaar has?


Running the Test Suite
======================

Currently, bzr selftest is used to invoke tests.
You can provide a pattern argument to run a subset. For example,
to run just the blackbox tests, run::

  ./bzr selftest -v blackbox

To skip a particular test (or set of tests), use the --exclude option
(shorthand -x) like so::

  ./bzr selftest -v -x blackbox

To ensure that all tests are being run and succeeding, you can use the
--strict option which will fail if there are any missing features or known
failures, like so::

  ./bzr selftest --strict

To list tests without running them, use the --list-only option like so::

  ./bzr selftest --list-only

This option can be combined with other selftest options (like -x) and
filter patterns to understand their effect.

Once you understand how to create a list of tests, you can use the --load-list
option to run only a restricted set of tests that you kept in a file, one test
id by line. Keep in mind that this will never be sufficient to validate your
modifications, you still need to run the full test suite for that, but using it
can help in some cases (like running only the failed tests for some time)::

  ./bzr selftest -- load-list my_failing_tests

This option can also be combined with other selftest options, including
patterns. It has some drawbacks though, the list can become out of date pretty
quick when doing Test Driven Development.

To address this concern, there is another way to run a restricted set of tests:
the --starting-with option will run only the tests whose name starts with the
specified string. It will also avoid loading the other tests and as a
consequence starts running your tests quicker::

  ./bzr selftest --starting-with bzrlib.blackbox

This option can be combined with all the other selftest options including
--load-list. The later is rarely used but allows to run a subset of a list of
failing tests for example.


Test suite debug flags
----------------------

Similar to the global ``-Dfoo`` debug options, bzr selftest accepts
``-E=foo`` debug flags.  These flags are:

:allow_debug: do *not* clear the global debug flags when running a test.
  This can provide useful logging to help debug test failures when used
  with e.g. ``bzr -Dhpss selftest -E=allow_debug``


Writing Tests
=============

Where should I put a new test?
------------------------------

Bzrlib's tests are organised by the type of test.  Most of the tests in
bzr's test suite belong to one of these categories:

 - Unit tests
 - Blackbox (UI) tests
 - Per-implementation tests
 - Doctests

A quick description of these test types and where they belong in bzrlib's
source follows.  Not all tests fall neatly into one of these categories;
in those cases use your judgement.


Unit tests
~~~~~~~~~~

Unit tests make up the bulk of our test suite.  These are tests that are
focused on exercising a single, specific unit of the code as directly
as possible.  Each unit test is generally fairly short and runs very
quickly.

They are found in ``bzrlib/tests/test_*.py``.  So in general tests should
be placed in a file named test_FOO.py where FOO is the logical thing under
test.

For example, tests for merge3 in bzrlib belong in bzrlib/tests/test_merge3.py.
See bzrlib/tests/test_sampler.py for a template test script.


Blackbox (UI) tests
~~~~~~~~~~~~~~~~~~~

Tests can be written for the UI or for individual areas of the library.
Choose whichever is appropriate: if adding a new command, or a new command
option, then you should be writing a UI test.  If you are both adding UI
functionality and library functionality, you will want to write tests for
both the UI and the core behaviours.  We call UI tests 'blackbox' tests
and they belong in ``bzrlib/tests/blackbox/*.py``.

When writing blackbox tests please honour the following conventions:

 1. Place the tests for the command 'name' in
    bzrlib/tests/blackbox/test_name.py. This makes it easy for developers
    to locate the test script for a faulty command.

 2. Use the 'self.run_bzr("name")' utility function to invoke the command
    rather than running bzr in a subprocess or invoking the
    cmd_object.run() method directly. This is a lot faster than
    subprocesses and generates the same logging output as running it in a
    subprocess (which invoking the method directly does not).
 
 3. Only test the one command in a single test script. Use the bzrlib
    library when setting up tests and when evaluating the side-effects of
    the command. We do this so that the library api has continual pressure
    on it to be as functional as the command line in a simple manner, and
    to isolate knock-on effects throughout the blackbox test suite when a
    command changes its name or signature. Ideally only the tests for a
    given command are affected when a given command is changed.

 4. If you have a test which does actually require running bzr in a
    subprocess you can use ``run_bzr_subprocess``. By default the spawned
    process will not load plugins unless ``--allow-plugins`` is supplied.


Per-implementation tests
~~~~~~~~~~~~~~~~~~~~~~~~

Per-implementation tests are tests that are defined once and then run
against multiple implementations of an interface.  For example,
``test_transport_implementations.py`` defines tests that all Transport
implementations (local filesystem, HTTP, and so on) must pass.

They are found in ``bzrlib/tests/*_implementations/test_*.py``,
``bzrlib/tests/per_*/*.py``, and
``bzrlib/tests/test_*_implementations.py``.

These are really a sub-category of unit tests, but an important one.


Doctests
~~~~~~~~

We make selective use of doctests__.  In general they should provide
*examples* within the API documentation which can incidentally be tested.  We
don't try to test every important case using doctests |--| regular Python
tests are generally a better solution.  That is, we just use doctests to
make our documentation testable, rather than as a way to make tests.

Most of these are in ``bzrlib/doc/api``.  More additions are welcome.

  __ http://docs.python.org/lib/module-doctest.html


.. Effort tests
.. ~~~~~~~~~~~~



Skipping tests
--------------

In our enhancements to unittest we allow for some addition results beyond
just success or failure.

If a test can't be run, it can say that it's skipped by raising a special
exception.  This is typically used in parameterized tests |--| for example
if a transport doesn't support setting permissions, we'll skip the tests
that relating to that.  ::

    try:
        return self.branch_format.initialize(repo.bzrdir)
    except errors.UninitializableFormat:
        raise tests.TestSkipped('Uninitializable branch format')

Raising TestSkipped is a good idea when you want to make it clear that the
test was not run, rather than just returning which makes it look as if it
was run and passed.

Several different cases are distinguished:

TestSkipped
        Generic skip; the only type that was present up to bzr 0.18.

TestNotApplicable
        The test doesn't apply to the parameters with which it was run.
        This is typically used when the test is being applied to all
        implementations of an interface, but some aspects of the interface
        are optional and not present in particular concrete
        implementations.  (Some tests that should raise this currently
        either silently return or raise TestSkipped.)  Another option is
        to use more precise parameterization to avoid generating the test
        at all.

TestPlatformLimit
        **(Not implemented yet)**
        The test can't be run because of an inherent limitation of the
        environment, such as not having symlinks or not supporting
        unicode.

UnavailableFeature
        The test can't be run because a dependency (typically a Python
        library) is not available in the test environment.  These
        are in general things that the person running the test could fix
        by installing the library.  It's OK if some of these occur when
        an end user runs the tests or if we're specifically testing in a
        limited environment, but a full test should never see them.

        See `Test feature dependencies`_ below.

KnownFailure
        The test exists but is known to fail, for example this might be
        appropriate to raise if you've committed a test for a bug but not
        the fix for it, or if something works on Unix but not on Windows.
        
        Raising this allows you to distinguish these failures from the
        ones that are not expected to fail.  If the test would fail
        because of something we don't expect or intend to fix,
        KnownFailure is not appropriate, and TestNotApplicable might be
        better.

        KnownFailure should be used with care as we don't want a
        proliferation of quietly broken tests.

We plan to support three modes for running the test suite to control the
interpretation of these results.  Strict mode is for use in situations
like merges to the mainline and releases where we want to make sure that
everything that can be tested has been tested.  Lax mode is for use by
developers who want to temporarily tolerate some known failures.  The
default behaviour is obtained by ``bzr selftest`` with no options, and
also (if possible) by running under another unittest harness.

======================= ======= ======= ========
result                  strict  default lax
======================= ======= ======= ========
TestSkipped             pass    pass    pass
TestNotApplicable       pass    pass    pass
TestPlatformLimit       pass    pass    pass
TestDependencyMissing   fail    pass    pass
KnownFailure            fail    pass    pass
======================= ======= ======= ========
     

Test feature dependencies
-------------------------

Writing tests that require a feature
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Rather than manually checking the environment in each test, a test class
can declare its dependence on some test features.  The feature objects are
checked only once for each run of the whole test suite.

(For historical reasons, as of May 2007 many cases that should depend on
features currently raise TestSkipped.)

For example::

    class TestStrace(TestCaseWithTransport):

        _test_needs_features = [StraceFeature]

This means all tests in this class need the feature.  The feature itself
should provide a ``_probe`` method which is called once to determine if
it's available.

These should generally be equivalent to either TestDependencyMissing or
sometimes TestPlatformLimit.

Individual tests can also require a feature using the ``requireFeature``
method::

    self.requireFeature(StraceFeature)

Features already defined in bzrlib.tests include:

 - SymlinkFeature,
 - HardlinkFeature,
 - OsFifoFeature,
 - UnicodeFilenameFeature,
 - FTPServerFeature, and
 - CaseInsensitiveFilesystemFeature.


Defining a new feature that tests can require
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

New features for use with ``_test_needs_features`` or ``requireFeature``
are defined by subclassing ``bzrlib.tests.Feature`` and overriding the
``_probe`` and ``feature_name`` methods.  For example::

    class _SymlinkFeature(Feature):
    
        def _probe(self):
            return osutils.has_symlinks()
    
        def feature_name(self):
            return 'symlinks'
    
    SymlinkFeature = _SymlinkFeature()


Testing exceptions and errors
-----------------------------

It's important to test handling of errors and exceptions.  Because this
code is often not hit in ad-hoc testing it can often have hidden bugs --
it's particularly common to get NameError because the exception code
references a variable that has since been renamed.

.. TODO: Something about how to provoke errors in the right way?

In general we want to test errors at two levels:

1. A test in ``test_errors.py`` checking that when the exception object is
   constructed with known parameters it produces an expected string form.
   This guards against mistakes in writing the format string, or in the
   ``str`` representations of its parameters.  There should be one for
   each exception class.

2. Tests that when an api is called in a particular situation, it raises
   an error of the expected class.  You should typically use
   ``assertRaises``, which in the Bazaar test suite returns the exception
   object to allow you to examine its parameters.

In some cases blackbox tests will also want to check error reporting.  But
it can be difficult to provoke every error through the commandline
interface, so those tests are only done as needed |--| eg in response to a
particular bug or if the error is reported in an unusual way(?)  Blackbox
tests should mostly be testing how the command-line interface works, so
should only test errors if there is something particular to the cli in how
they're displayed or handled.


Testing warnings
----------------

The Python ``warnings`` module is used to indicate a non-fatal code
problem.  Code that's expected to raise a warning can be tested through
callCatchWarnings.

The test suite can be run with ``-Werror`` to check no unexpected errors
occur.

However, warnings should be used with discretion.  It's not an appropriate
way to give messages to the user, because the warning is normally shown
only once per source line that causes the problem.  You should also think
about whether the warning is serious enought that it should be visible to
users who may not be able to fix it.


Interface implementation testing and test scenarios
---------------------------------------------------

There are several cases in Bazaar of multiple implementations of a common
conceptual interface.  ("Conceptual" because it's not necessary for all
the implementations to share a base class, though they often do.)
Examples include transports and the working tree, branch and repository
classes.

In these cases we want to make sure that every implementation correctly
fulfils the interface requirements.  For example, every Transport should
support the ``has()`` and ``get()`` and ``clone()`` methods.  We have a
sub-suite of tests in ``test_transport_implementations``.  (Most
per-implementation tests are in submodules of ``bzrlib.tests``, but not
the transport tests at the moment.)

These tests are repeated for each registered Transport, by generating a
new TestCase instance for the cross product of test methods and transport
implementations.  As each test runs, it has ``transport_class`` and
``transport_server`` set to the class it should test.  Most tests don't
access these directly, but rather use ``self.get_transport`` which returns
a transport of the appropriate type.

The goal is to run per-implementation only the tests that relate to that
particular interface.  Sometimes we discover a bug elsewhere that happens
with only one particular transport.  Once it's isolated, we can consider
whether a test should be added for that particular implementation,
or for all implementations of the interface.

The multiplication of tests for different implementations is normally
accomplished by overriding the ``load_tests`` function used to load tests
from a module.  This function typically loads all the tests, then applies
a TestProviderAdapter to them, which generates a longer suite containing
all the test variations.

See also `Per-implementation tests`_ (above).


Test scenarios
--------------

Some utilities are provided for generating variations of tests.  This can
be used for per-implementation tests, or other cases where the same test
code needs to run several times on different scenarios.

The general approach is to define a class that provides test methods,
which depend on attributes of the test object being pre-set with the
values to which the test should be applied.  The test suite should then
also provide a list of scenarios in which to run the tests.

Typically ``multiply_tests_from_modules`` should be called from the test
module's ``load_tests`` function.


Test support
------------

We have a rich collection of tools to support writing tests. Please use
them in preference to ad-hoc solutions as they provide portability and
performance benefits.


TestCase and its subclasses
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``bzrlib.tests`` module defines many TestCase classes to help you
write your tests.

TestCase
    A base TestCase that extends the Python standard library's
    TestCase in several ways.  It adds more assertion methods (e.g.
    ``assertContainsRe``), ``addCleanup``, and other features (see its API
    docs for details).  It also has a ``setUp`` that makes sure that
    global state like registered hooks and loggers won't interfere with
    your test.  All tests should use this base class (whether directly or
    via a subclass).

TestCaseWithMemoryTransport
    Extends TestCase and adds methods like ``get_transport``,
    ``make_branch`` and ``make_branch_builder``.  The files created are
    stored in a MemoryTransport that is discarded at the end of the test.
    This class is good for tests that need to make branches or use
    transports, but that don't require storing things on disk.  All tests
    that create bzrdirs should use this base class (either directly or via
    a subclass) as it ensures that the test won't accidentally operate on
    real branches in your filesystem.

TestCaseInTempDir
    Extends TestCaseWithMemoryTransport.  For tests that really do need
    files to be stored on disk, e.g. because a subprocess uses a file, or
    for testing functionality that accesses the filesystem directly rather
    than via the Transport layer (such as dirstate).

TestCaseWithTransport
    Extends TestCaseInTempDir.  Provides ``get_url`` and
    ``get_readonly_url`` facilities.  Subclasses can control the
    transports used by setting ``vfs_transport_factory``,
    ``transport_server`` and/or ``transport_readonly_server``.


See the API docs for more details.


BranchBuilder
~~~~~~~~~~~~~

When writing a test for a feature, it is often necessary to set up a
branch with a certain history.  The ``BranchBuilder`` interface allows the
creation of test branches in a quick and easy manner.  Here's a sample
session::

  builder = self.make_branch_builder('relpath')
  builder.build_commit()
  builder.build_commit()
  builder.build_commit()
  branch = builder.get_branch()

``make_branch_builder`` is a method of ``TestCaseWithMemoryTransport``.

Note that many current tests create test branches by inheriting from
``TestCaseWithTransport`` and using the ``make_branch_and_tree`` helper to
give them a ``WorkingTree`` that they can commit to. However, using the
newer ``make_branch_builder`` helper is preferred, because it can build
the changes in memory, rather than on disk. Tests that are explictly
testing how we work with disk objects should, of course, use a real
``WorkingTree``.

Please see bzrlib.branchbuilder for more details.


TreeBuilder
~~~~~~~~~~~

The ``TreeBuilder`` interface allows the construction of arbitrary trees
with a declarative interface. A sample session might look like::

  tree = self.make_branch_and_tree('path')
  builder = TreeBuilder()
  builder.start_tree(tree)
  builder.build(['foo', "bar/", "bar/file"])
  tree.commit('commit the tree')
  builder.finish_tree()

Usually a test will create a tree using ``make_branch_and_memory_tree`` (a
method of ``TestCaseWithMemoryTransport``) or ``make_branch_and_tree`` (a
method of ``TestCaseWithTransport``).

Please see bzrlib.treebuilder for more details.


.. |--| unicode:: U+2014

..
   vim: ft=rst tw=74 ai
